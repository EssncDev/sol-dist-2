{"ast":null,"code":"/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// @ts-ignore\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst utils_1 = require(\"./utils\");\nclass CommonClient extends eventemitter3_1.EventEmitter {\n  address;\n  rpc_id;\n  queue;\n  options;\n  autoconnect;\n  ready;\n  reconnect;\n  reconnect_timer_id;\n  reconnect_interval;\n  max_reconnects;\n  rest_options;\n  current_reconnects;\n  generate_request_id;\n  socket;\n  webSocketFactory;\n  dataPack;\n  /**\n   * Instantiate a Client class.\n   * @constructor\n   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n   * @param {String} address - url to a websocket server\n   * @param {Object} options - ws options object with reconnect parameters\n   * @param {Function} generate_request_id - custom generation request Id\n   * @param {DataPack} dataPack - data pack contains encoder and decoder\n   * @return {CommonClient}\n   */\n  constructor(webSocketFactory, address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1000,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id, dataPack) {\n    super();\n    this.webSocketFactory = webSocketFactory;\n    this.queue = {};\n    this.rpc_id = 0;\n    this.address = address;\n    this.autoconnect = autoconnect;\n    this.ready = false;\n    this.reconnect = reconnect;\n    this.reconnect_timer_id = undefined;\n    this.reconnect_interval = reconnect_interval;\n    this.max_reconnects = max_reconnects;\n    this.rest_options = rest_options;\n    this.current_reconnects = 0;\n    this.generate_request_id = generate_request_id || (() => ++this.rpc_id);\n    if (!dataPack) this.dataPack = new utils_1.DefaultDataPack();else this.dataPack = dataPack;\n    if (this.autoconnect) this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n   * Connects to a defined server if not connected already.\n   * @method\n   * @return {Undefined}\n   */\n  connect() {\n    if (this.socket) return;\n    this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n   * Calls a registered RPC method on server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object|Array} params - optional method parameters\n   * @param {Number} timeout - RPC reply timeout value\n   * @param {Object} ws_opts - options passed to ws\n   * @return {Promise}\n   */\n  call(method, params, timeout, ws_opts) {\n    if (!ws_opts && \"object\" === typeof timeout) {\n      ws_opts = timeout;\n      timeout = null;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const rpc_id = this.generate_request_id(method, params);\n      const message = {\n        jsonrpc: \"2.0\",\n        method: method,\n        params: params || undefined,\n        id: rpc_id\n      };\n      this.socket.send(this.dataPack.encode(message), ws_opts, error => {\n        if (error) return reject(error);\n        this.queue[rpc_id] = {\n          promise: [resolve, reject]\n        };\n        if (timeout) {\n          this.queue[rpc_id].timeout = setTimeout(() => {\n            delete this.queue[rpc_id];\n            reject(new Error(\"reply timeout\"));\n          }, timeout);\n        }\n      });\n    });\n  }\n  /**\n   * Logins with the other side of the connection.\n   * @method\n   * @param {Object} params - Login credentials object\n   * @return {Promise}\n   */\n  async login(params) {\n    const resp = await this.call(\"rpc.login\", params);\n    if (!resp) throw new Error(\"authentication failed\");\n    return resp;\n  }\n  /**\n   * Fetches a list of client's methods registered on server.\n   * @method\n   * @return {Array}\n   */\n  async listMethods() {\n    return await this.call(\"__listMethods\");\n  }\n  /**\n   * Sends a JSON-RPC 2.0 notification to server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object} params - optional method parameters\n   * @return {Promise}\n   */\n  notify(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const message = {\n        jsonrpc: \"2.0\",\n        method: method,\n        params\n      };\n      this.socket.send(this.dataPack.encode(message), error => {\n        if (error) return reject(error);\n        resolve();\n      });\n    });\n  }\n  /**\n   * Subscribes for a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n  async subscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.on\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n    return result;\n  }\n  /**\n   * Unsubscribes from a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n  async unsubscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.off\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n    return result;\n  }\n  /**\n   * Closes a WebSocket connection gracefully.\n   * @method\n   * @param {Number} code - socket close code\n   * @param {String} data - optional data to be sent before closing\n   * @return {Undefined}\n   */\n  close(code, data) {\n    this.socket.close(code || 1000, data);\n  }\n  /**\n   * Enable / disable automatic reconnection.\n   * @method\n   * @param {Boolean} reconnect - enable / disable reconnection\n   * @return {Undefined}\n   */\n  setAutoReconnect(reconnect) {\n    this.reconnect = reconnect;\n  }\n  /**\n   * Set the interval between reconnection attempts.\n   * @method\n   * @param {Number} interval - reconnection interval in milliseconds\n   * @return {Undefined}\n   */\n  setReconnectInterval(interval) {\n    this.reconnect_interval = interval;\n  }\n  /**\n   * Set the maximum number of reconnection attempts.\n   * @method\n   * @param {Number} max_reconnects - maximum reconnection attempts\n   * @return {Undefined}\n   */\n  setMaxReconnects(max_reconnects) {\n    this.max_reconnects = max_reconnects;\n  }\n  /**\n   * Connection/Message handler.\n   * @method\n   * @private\n   * @param {String} address - WebSocket API address\n   * @param {Object} options - ws options object\n   * @return {Undefined}\n   */\n  _connect(address, options) {\n    clearTimeout(this.reconnect_timer_id);\n    this.socket = this.webSocketFactory(address, options);\n    this.socket.addEventListener(\"open\", () => {\n      this.ready = true;\n      this.emit(\"open\");\n      this.current_reconnects = 0;\n    });\n    this.socket.addEventListener(\"message\", ({\n      data: message\n    }) => {\n      if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n      try {\n        message = this.dataPack.decode(message);\n      } catch (error) {\n        return;\n      }\n      // check if any listeners are attached and forward event\n      if (message.notification && this.listeners(message.notification).length) {\n        if (!Object.keys(message.params).length) return this.emit(message.notification);\n        const args = [message.notification];\n        if (message.params.constructor === Object) args.push(message.params);else\n          // using for-loop instead of unshift/spread because performance is better\n          for (let i = 0; i < message.params.length; i++) args.push(message.params[i]);\n        // run as microtask so that pending queue messages are resolved first\n        // eslint-disable-next-line prefer-spread\n        return Promise.resolve().then(() => {\n          this.emit.apply(this, args);\n        });\n      }\n      if (!this.queue[message.id]) {\n        // general JSON RPC 2.0 events\n        if (message.method) {\n          // run as microtask so that pending queue messages are resolved first\n          return Promise.resolve().then(() => {\n            this.emit(message.method, message?.params);\n          });\n        }\n        return;\n      }\n      // reject early since server's response is invalid\n      if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error(\"Server response malformed. Response must include either \\\"result\\\"\" + \" or \\\"error\\\", but not both.\"));\n      if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n      if (message.error) this.queue[message.id].promise[1](message.error);else this.queue[message.id].promise[0](message.result);\n      delete this.queue[message.id];\n    });\n    this.socket.addEventListener(\"error\", error => this.emit(\"error\", error));\n    this.socket.addEventListener(\"close\", ({\n      code,\n      reason\n    }) => {\n      if (this.ready)\n        // Delay close event until internal state is updated\n        setTimeout(() => this.emit(\"close\", code, reason), 0);\n      this.ready = false;\n      this.socket = undefined;\n      if (code === 1000) return;\n      this.current_reconnects++;\n      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);\n    });\n  }\n}\nexports.default = CommonClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","eventemitter3_1","require","utils_1","CommonClient","EventEmitter","address","rpc_id","queue","options","autoconnect","ready","reconnect","reconnect_timer_id","reconnect_interval","max_reconnects","rest_options","current_reconnects","generate_request_id","socket","webSocketFactory","dataPack","constructor","undefined","DefaultDataPack","_connect","connect","call","method","params","timeout","ws_opts","Promise","resolve","reject","Error","message","jsonrpc","id","send","encode","error","promise","setTimeout","login","resp","listMethods","notify","subscribe","event","result","unsubscribe","close","code","data","setAutoReconnect","setReconnectInterval","interval","setMaxReconnects","clearTimeout","addEventListener","emit","ArrayBuffer","Buffer","from","toString","decode","notification","listeners","length","keys","args","push","i","then","apply","reason","default"],"sources":["/Users/Devdev/Desktop/JS/React/sol-dist-2/node_modules/rpc-websockets/dist/lib/client.js"],"sourcesContent":["/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-ignore\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst utils_1 = require(\"./utils\");\nclass CommonClient extends eventemitter3_1.EventEmitter {\n    address;\n    rpc_id;\n    queue;\n    options;\n    autoconnect;\n    ready;\n    reconnect;\n    reconnect_timer_id;\n    reconnect_interval;\n    max_reconnects;\n    rest_options;\n    current_reconnects;\n    generate_request_id;\n    socket;\n    webSocketFactory;\n    dataPack;\n    /**\n     * Instantiate a Client class.\n     * @constructor\n     * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n     * @param {String} address - url to a websocket server\n     * @param {Object} options - ws options object with reconnect parameters\n     * @param {Function} generate_request_id - custom generation request Id\n     * @param {DataPack} dataPack - data pack contains encoder and decoder\n     * @return {CommonClient}\n     */\n    constructor(webSocketFactory, address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1000, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack) {\n        super();\n        this.webSocketFactory = webSocketFactory;\n        this.queue = {};\n        this.rpc_id = 0;\n        this.address = address;\n        this.autoconnect = autoconnect;\n        this.ready = false;\n        this.reconnect = reconnect;\n        this.reconnect_timer_id = undefined;\n        this.reconnect_interval = reconnect_interval;\n        this.max_reconnects = max_reconnects;\n        this.rest_options = rest_options;\n        this.current_reconnects = 0;\n        this.generate_request_id = generate_request_id || (() => ++this.rpc_id);\n        if (!dataPack)\n            this.dataPack = new utils_1.DefaultDataPack();\n        else\n            this.dataPack = dataPack;\n        if (this.autoconnect)\n            this._connect(this.address, {\n                autoconnect: this.autoconnect,\n                reconnect: this.reconnect,\n                reconnect_interval: this.reconnect_interval,\n                max_reconnects: this.max_reconnects,\n                ...this.rest_options\n            });\n    }\n    /**\n     * Connects to a defined server if not connected already.\n     * @method\n     * @return {Undefined}\n     */\n    connect() {\n        if (this.socket)\n            return;\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n     * Calls a registered RPC method on server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object|Array} params - optional method parameters\n     * @param {Number} timeout - RPC reply timeout value\n     * @param {Object} ws_opts - options passed to ws\n     * @return {Promise}\n     */\n    call(method, params, timeout, ws_opts) {\n        if (!ws_opts && \"object\" === typeof timeout) {\n            ws_opts = timeout;\n            timeout = null;\n        }\n        return new Promise((resolve, reject) => {\n            if (!this.ready)\n                return reject(new Error(\"socket not ready\"));\n            const rpc_id = this.generate_request_id(method, params);\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params: params || undefined,\n                id: rpc_id\n            };\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {\n                if (error)\n                    return reject(error);\n                this.queue[rpc_id] = { promise: [resolve, reject] };\n                if (timeout) {\n                    this.queue[rpc_id].timeout = setTimeout(() => {\n                        delete this.queue[rpc_id];\n                        reject(new Error(\"reply timeout\"));\n                    }, timeout);\n                }\n            });\n        });\n    }\n    /**\n     * Logins with the other side of the connection.\n     * @method\n     * @param {Object} params - Login credentials object\n     * @return {Promise}\n     */\n    async login(params) {\n        const resp = await this.call(\"rpc.login\", params);\n        if (!resp)\n            throw new Error(\"authentication failed\");\n        return resp;\n    }\n    /**\n     * Fetches a list of client's methods registered on server.\n     * @method\n     * @return {Array}\n     */\n    async listMethods() {\n        return await this.call(\"__listMethods\");\n    }\n    /**\n     * Sends a JSON-RPC 2.0 notification to server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object} params - optional method parameters\n     * @return {Promise}\n     */\n    notify(method, params) {\n        return new Promise((resolve, reject) => {\n            if (!this.ready)\n                return reject(new Error(\"socket not ready\"));\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params\n            };\n            this.socket.send(this.dataPack.encode(message), (error) => {\n                if (error)\n                    return reject(error);\n                resolve();\n            });\n        });\n    }\n    /**\n     * Subscribes for a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n    async subscribe(event) {\n        if (typeof event === \"string\")\n            event = [event];\n        const result = await this.call(\"rpc.on\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n        return result;\n    }\n    /**\n     * Unsubscribes from a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n    async unsubscribe(event) {\n        if (typeof event === \"string\")\n            event = [event];\n        const result = await this.call(\"rpc.off\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed unsubscribing from an event with: \" + result);\n        return result;\n    }\n    /**\n     * Closes a WebSocket connection gracefully.\n     * @method\n     * @param {Number} code - socket close code\n     * @param {String} data - optional data to be sent before closing\n     * @return {Undefined}\n     */\n    close(code, data) {\n        this.socket.close(code || 1000, data);\n    }\n    /**\n     * Enable / disable automatic reconnection.\n     * @method\n     * @param {Boolean} reconnect - enable / disable reconnection\n     * @return {Undefined}\n     */\n    setAutoReconnect(reconnect) {\n        this.reconnect = reconnect;\n    }\n    /**\n     * Set the interval between reconnection attempts.\n     * @method\n     * @param {Number} interval - reconnection interval in milliseconds\n     * @return {Undefined}\n     */\n    setReconnectInterval(interval) {\n        this.reconnect_interval = interval;\n    }\n    /**\n     * Set the maximum number of reconnection attempts.\n     * @method\n     * @param {Number} max_reconnects - maximum reconnection attempts\n     * @return {Undefined}\n     */\n    setMaxReconnects(max_reconnects) {\n        this.max_reconnects = max_reconnects;\n    }\n    /**\n     * Connection/Message handler.\n     * @method\n     * @private\n     * @param {String} address - WebSocket API address\n     * @param {Object} options - ws options object\n     * @return {Undefined}\n     */\n    _connect(address, options) {\n        clearTimeout(this.reconnect_timer_id);\n        this.socket = this.webSocketFactory(address, options);\n        this.socket.addEventListener(\"open\", () => {\n            this.ready = true;\n            this.emit(\"open\");\n            this.current_reconnects = 0;\n        });\n        this.socket.addEventListener(\"message\", ({ data: message }) => {\n            if (message instanceof ArrayBuffer)\n                message = Buffer.from(message).toString();\n            try {\n                message = this.dataPack.decode(message);\n            }\n            catch (error) {\n                return;\n            }\n            // check if any listeners are attached and forward event\n            if (message.notification && this.listeners(message.notification).length) {\n                if (!Object.keys(message.params).length)\n                    return this.emit(message.notification);\n                const args = [message.notification];\n                if (message.params.constructor === Object)\n                    args.push(message.params);\n                else\n                    // using for-loop instead of unshift/spread because performance is better\n                    for (let i = 0; i < message.params.length; i++)\n                        args.push(message.params[i]);\n                // run as microtask so that pending queue messages are resolved first\n                // eslint-disable-next-line prefer-spread\n                return Promise.resolve().then(() => { this.emit.apply(this, args); });\n            }\n            if (!this.queue[message.id]) {\n                // general JSON RPC 2.0 events\n                if (message.method) {\n                    // run as microtask so that pending queue messages are resolved first\n                    return Promise.resolve().then(() => {\n                        this.emit(message.method, message?.params);\n                    });\n                }\n                return;\n            }\n            // reject early since server's response is invalid\n            if (\"error\" in message === \"result\" in message)\n                this.queue[message.id].promise[1](new Error(\"Server response malformed. Response must include either \\\"result\\\"\" +\n                    \" or \\\"error\\\", but not both.\"));\n            if (this.queue[message.id].timeout)\n                clearTimeout(this.queue[message.id].timeout);\n            if (message.error)\n                this.queue[message.id].promise[1](message.error);\n            else\n                this.queue[message.id].promise[0](message.result);\n            delete this.queue[message.id];\n        });\n        this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error));\n        this.socket.addEventListener(\"close\", ({ code, reason }) => {\n            if (this.ready) // Delay close event until internal state is updated\n                setTimeout(() => this.emit(\"close\", code, reason), 0);\n            this.ready = false;\n            this.socket = undefined;\n            if (code === 1000)\n                return;\n            this.current_reconnects++;\n            if (this.reconnect && ((this.max_reconnects > this.current_reconnects) ||\n                this.max_reconnects === 0))\n                this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);\n        });\n    }\n}\nexports.default = CommonClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}